{"version":3,"sources":["../src/index.ts","../src/use-chat.ts","../src/use-completion.ts"],"sourcesContent":["export * from './use-chat';\nexport * from './use-completion';\n","import type {\n  ChatRequest,\n  ChatRequestOptions,\n  CreateMessage,\n  JSONValue,\n  Message,\n  UseChatOptions,\n} from '@ai-sdk/ui-utils';\nimport {\n  callChatApi,\n  generateId as generateIdFunc,\n  processChatStream,\n} from '@ai-sdk/ui-utils';\nimport swrv from 'swrv';\nimport type { Ref } from 'vue';\nimport { ref, unref } from 'vue';\n\nexport type { CreateMessage, Message, UseChatOptions };\n\nexport type UseChatHelpers = {\n  /** Current messages in the chat */\n  messages: Ref<Message[]>;\n  /** The error object of the API request */\n  error: Ref<undefined | Error>;\n  /**\n   * Append a user message to the chat list. This triggers the API call to fetch\n   * the assistant's response.\n   */\n  append: (\n    message: Message | CreateMessage,\n    chatRequestOptions?: ChatRequestOptions,\n  ) => Promise<string | null | undefined>;\n  /**\n   * Reload the last AI chat response for the given chat history. If the last\n   * message isn't from the assistant, it will request the API to generate a\n   * new response.\n   */\n  reload: (\n    chatRequestOptions?: ChatRequestOptions,\n  ) => Promise<string | null | undefined>;\n  /**\n   * Abort the current request immediately, keep the generated tokens if any.\n   */\n  stop: () => void;\n  /**\n   * Update the `messages` state locally. This is useful when you want to\n   * edit the messages on the client, and then trigger the `reload` method\n   * manually to regenerate the AI response.\n   */\n  setMessages: (messages: Message[]) => void;\n  /** The current value of the input */\n  input: Ref<string>;\n  /** Form submission handler to automatically reset input and append a user message  */\n  handleSubmit: (\n    event?: { preventDefault?: () => void },\n    chatRequestOptions?: ChatRequestOptions,\n  ) => void;\n  /** Whether the API request is in progress */\n  isLoading: Ref<boolean | undefined>;\n\n  /** Additional data added on the server via StreamData */\n  data: Ref<JSONValue[] | undefined>;\n};\n\nlet uniqueId = 0;\n\n// @ts-expect-error - some issues with the default export of useSWRV\nconst useSWRV = (swrv.default as typeof import('swrv')['default']) || swrv;\nconst store: Record<string, Message[] | undefined> = {};\n\nexport function useChat({\n  api = '/api/chat',\n  id,\n  initialMessages = [],\n  initialInput = '',\n  sendExtraMessageFields,\n  experimental_onFunctionCall,\n  streamMode,\n  onResponse,\n  onFinish,\n  onError,\n  credentials,\n  headers,\n  body,\n  generateId = generateIdFunc,\n  fetch,\n}: UseChatOptions = {}): UseChatHelpers {\n  // Generate a unique ID for the chat if not provided.\n  const chatId = id || `chat-${uniqueId++}`;\n\n  const key = `${api}|${chatId}`;\n  const { data: messagesData, mutate: originalMutate } = useSWRV<Message[]>(\n    key,\n    () => store[key] || initialMessages,\n  );\n\n  const { data: isLoading, mutate: mutateLoading } = useSWRV<boolean>(\n    `${chatId}-loading`,\n    null,\n  );\n\n  isLoading.value ??= false;\n\n  // Force the `data` to be `initialMessages` if it's `undefined`.\n  messagesData.value ??= initialMessages;\n\n  const mutate = (data?: Message[]) => {\n    store[key] = data;\n    return originalMutate();\n  };\n\n  // Because of the `initialData` option, the `data` will never be `undefined`.\n  const messages = messagesData as Ref<Message[]>;\n\n  const error = ref<undefined | Error>(undefined);\n  // cannot use JSONValue[] in ref because of infinite Typescript recursion:\n  const streamData = ref<undefined | unknown[]>(undefined);\n\n  let abortController: AbortController | null = null;\n  async function triggerRequest(\n    messagesSnapshot: Message[],\n    { options, data }: ChatRequestOptions = {},\n  ) {\n    try {\n      error.value = undefined;\n      mutateLoading(() => true);\n\n      abortController = new AbortController();\n\n      // Do an optimistic update to the chat state to show the updated messages\n      // immediately.\n      const previousMessages = messagesData.value;\n      mutate(messagesSnapshot);\n\n      let chatRequest: ChatRequest = {\n        messages: messagesSnapshot,\n        options,\n        data,\n      };\n\n      await processChatStream({\n        getStreamedResponse: async () => {\n          const existingData = (streamData.value ?? []) as JSONValue[];\n\n          const constructedMessagesPayload = sendExtraMessageFields\n            ? chatRequest.messages\n            : chatRequest.messages.map(\n                ({\n                  role,\n                  content,\n                  name,\n                  data,\n                  annotations,\n                  function_call,\n                }) => ({\n                  role,\n                  content,\n                  ...(name !== undefined && { name }),\n                  ...(data !== undefined && { data }),\n                  ...(annotations !== undefined && { annotations }),\n                  // outdated function/tool call handling (TODO deprecate):\n                  ...(function_call !== undefined && { function_call }),\n                }),\n              );\n\n          return await callChatApi({\n            api,\n            body: {\n              messages: constructedMessagesPayload,\n              data: chatRequest.data,\n              ...unref(body), // Use unref to unwrap the ref value\n              ...options?.body,\n            },\n            streamMode,\n            headers: {\n              ...headers,\n              ...options?.headers,\n            },\n            abortController: () => abortController,\n            credentials,\n            onResponse,\n            onUpdate(merged, data) {\n              mutate([...chatRequest.messages, ...merged]);\n              streamData.value = [...existingData, ...(data ?? [])];\n            },\n            onFinish(message) {\n              // workaround: sometimes the last chunk is not shown in the UI.\n              // push it twice to make sure it's displayed.\n              mutate([...chatRequest.messages, message]);\n              onFinish?.(message);\n            },\n            restoreMessagesOnFailure() {\n              // Restore the previous messages if the request fails.\n              mutate(previousMessages);\n            },\n            generateId,\n            onToolCall: undefined, // not implemented yet\n            fetch,\n          });\n        },\n        experimental_onFunctionCall,\n        updateChatRequest(newChatRequest) {\n          chatRequest = newChatRequest;\n        },\n        getCurrentMessages: () => messages.value,\n      });\n\n      abortController = null;\n    } catch (err) {\n      // Ignore abort errors as they are expected.\n      if ((err as any).name === 'AbortError') {\n        abortController = null;\n        return null;\n      }\n\n      if (onError && err instanceof Error) {\n        onError(err);\n      }\n\n      error.value = err as Error;\n    } finally {\n      mutateLoading(() => false);\n    }\n  }\n\n  const append: UseChatHelpers['append'] = async (message, options) => {\n    if (!message.id) {\n      message.id = generateId();\n    }\n    return triggerRequest(messages.value.concat(message as Message), options);\n  };\n\n  const reload: UseChatHelpers['reload'] = async options => {\n    const messagesSnapshot = messages.value;\n    if (messagesSnapshot.length === 0) return null;\n\n    const lastMessage = messagesSnapshot[messagesSnapshot.length - 1];\n    if (lastMessage.role === 'assistant') {\n      return triggerRequest(messagesSnapshot.slice(0, -1), options);\n    }\n    return triggerRequest(messagesSnapshot, options);\n  };\n\n  const stop = () => {\n    if (abortController) {\n      abortController.abort();\n      abortController = null;\n    }\n  };\n\n  const setMessages = (messages: Message[]) => {\n    mutate(messages);\n  };\n\n  const input = ref(initialInput);\n\n  const handleSubmit = (\n    event?: { preventDefault?: () => void },\n    options: ChatRequestOptions = {},\n  ) => {\n    event?.preventDefault?.();\n\n    const inputValue = input.value;\n    if (!inputValue) return;\n    append(\n      {\n        content: inputValue,\n        role: 'user',\n      },\n      options,\n    );\n    input.value = '';\n  };\n\n  return {\n    messages,\n    append,\n    error,\n    reload,\n    stop,\n    setMessages,\n    input,\n    handleSubmit,\n    isLoading,\n    data: streamData as Ref<undefined | JSONValue[]>,\n  };\n}\n","import type {\n  JSONValue,\n  RequestOptions,\n  UseCompletionOptions,\n} from '@ai-sdk/ui-utils';\nimport { callCompletionApi } from '@ai-sdk/ui-utils';\nimport swrv from 'swrv';\nimport type { Ref } from 'vue';\nimport { ref, unref } from 'vue';\n\nexport type { UseCompletionOptions };\n\nexport type UseCompletionHelpers = {\n  /** The current completion result */\n  completion: Ref<string>;\n  /** The error object of the API request */\n  error: Ref<undefined | Error>;\n  /**\n   * Send a new prompt to the API endpoint and update the completion state.\n   */\n  complete: (\n    prompt: string,\n    options?: RequestOptions,\n  ) => Promise<string | null | undefined>;\n  /**\n   * Abort the current API request but keep the generated tokens.\n   */\n  stop: () => void;\n  /**\n   * Update the `completion` state locally.\n   */\n  setCompletion: (completion: string) => void;\n  /** The current value of the input */\n  input: Ref<string>;\n  /**\n   * Form submission handler to automatically reset input and append a user message\n   * @example\n   * ```jsx\n   * <form @submit=\"handleSubmit\">\n   *  <input @change=\"handleInputChange\" v-model=\"input\" />\n   * </form>\n   * ```\n   */\n  handleSubmit: (event?: { preventDefault?: () => void }) => void;\n  /** Whether the API request is in progress */\n  isLoading: Ref<boolean | undefined>;\n\n  /** Additional data added on the server via StreamData */\n  data: Ref<JSONValue[] | undefined>;\n};\n\nlet uniqueId = 0;\n\n// @ts-expect-error - some issues with the default export of useSWRV\nconst useSWRV = (swrv.default as typeof import('swrv')['default']) || swrv;\nconst store: Record<string, any> = {};\n\nexport function useCompletion({\n  api = '/api/completion',\n  id,\n  initialCompletion = '',\n  initialInput = '',\n  credentials,\n  headers,\n  body,\n  streamMode,\n  onResponse,\n  onFinish,\n  onError,\n  fetch,\n}: UseCompletionOptions = {}): UseCompletionHelpers {\n  // Generate an unique id for the completion if not provided.\n  const completionId = id || `completion-${uniqueId++}`;\n\n  const key = `${api}|${completionId}`;\n  const { data, mutate: originalMutate } = useSWRV<string>(\n    key,\n    () => store[key] || initialCompletion,\n  );\n\n  const { data: isLoading, mutate: mutateLoading } = useSWRV<boolean>(\n    `${completionId}-loading`,\n    null,\n  );\n\n  isLoading.value ??= false;\n\n  const { data: streamData, mutate: mutateStreamData } = useSWRV<\n    JSONValue[] | undefined\n  >(`${completionId}-data`, null);\n\n  // Force the `data` to be `initialCompletion` if it's `undefined`.\n  data.value ||= initialCompletion;\n\n  const mutate = (data: string) => {\n    store[key] = data;\n    return originalMutate();\n  };\n\n  // Because of the `initialData` option, the `data` will never be `undefined`.\n  const completion = data as Ref<string>;\n\n  const error = ref<undefined | Error>(undefined);\n\n  let abortController: AbortController | null = null;\n\n  async function triggerRequest(prompt: string, options?: RequestOptions) {\n    const existingData = (streamData.value ?? []) as JSONValue[];\n    return callCompletionApi({\n      api,\n      prompt,\n      credentials,\n      headers: {\n        ...headers,\n        ...options?.headers,\n      },\n      body: {\n        ...unref(body),\n        ...options?.body,\n      },\n      streamMode,\n      setCompletion: mutate,\n      setLoading: loading => mutateLoading(() => loading),\n      setError: err => {\n        error.value = err;\n      },\n      setAbortController: controller => {\n        abortController = controller;\n      },\n      onResponse,\n      onFinish,\n      onError,\n      onData: data => {\n        mutateStreamData(() => [...existingData, ...(data ?? [])]);\n      },\n      fetch,\n    });\n  }\n\n  const complete: UseCompletionHelpers['complete'] = async (\n    prompt,\n    options,\n  ) => {\n    return triggerRequest(prompt, options);\n  };\n\n  const stop = () => {\n    if (abortController) {\n      abortController.abort();\n      abortController = null;\n    }\n  };\n\n  const setCompletion = (completion: string) => {\n    mutate(completion);\n  };\n\n  const input = ref(initialInput);\n\n  const handleSubmit = (event?: { preventDefault?: () => void }) => {\n    event?.preventDefault?.();\n    const inputValue = input.value;\n    return inputValue ? complete(inputValue) : undefined;\n  };\n\n  return {\n    completion,\n    complete,\n    error,\n    stop,\n    setCompletion,\n    input,\n    handleSubmit,\n    isLoading,\n    data: streamData,\n  };\n}\n"],"mappings":"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","names":["swrv","generateIdFunc","_a","data","messages","import_ui_utils","import_swrv","import_vue","uniqueId","useSWRV","swrv","store","data","_a","completion"]}